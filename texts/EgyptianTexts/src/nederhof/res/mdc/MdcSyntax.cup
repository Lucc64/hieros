/***************************************************************************/
/*                                                                         */
/*  MdcSyntax.cup                                                          */
/*                                                                         */
/*  Copyright (c) 2008 Mark-Jan Nederhof                                   */
/*                                                                         */
/*  This file is part of the implementation of AELalign, and may only be   */
/*  used, modified, and distributed under the terms of the                 */
/*  GNU General Public License (see doc/GPL.TXT).                          */
/*  By continuing to use, modify, or distribute this file you indicate     */
/*  that you have read the license and understand and accept it fully.     */
/*                                                                         */
/***************************************************************************/

// Cup specification of MDC-88 (see Buurman et al., 1988).
// See http://www.catchpenny.org/codage/ for online MDC documentation (MDC-97).
// See also the MDC parser in JSesh by Rosmorduc.

package nederhof.res.mdc;

import java.awt.Point;
import java.io.*;
import java.util.*;

import java_cup.runtime.*;

import nederhof.res.*;

parser code {:

    // Error messages are collected as strings.
    protected Vector errors = new Vector();

    // If first error has position, then this is it.
    public Point errorPosition = new Point(-1, -1);

    // String that is parsed. Kept for error reporting.
    private String string;

    // Auxiliary methods for conversion.
    public MdcResAux aux;

    // Construct parser by making lexer and storing input string.
    protected parser(String string, MdcResAux aux) {
        super(new lexer(new StringReader(string)));
        this.string = string;
        this.aux = aux;
    }

    // Create error message.
    public void report_error(String message, Object info) {
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol sym = (java_cup.runtime.Symbol) info;
            int charPos = sym.left;
            int lineNo = sym.right;
            reportError(message, charPos, lineNo);
        } else
            errors.add(message + "\n");
    }

    // Create error message with character position and line number.
    // Print previous and next line(s).
    protected void reportError(String message, int charPos, int lineNo) {
        if (lineNo >= 0 && charPos >= 0) {
	    if (errors.isEmpty())
		errorPosition = new Point(lineNo, charPos);
            int fromPos = string.lastIndexOf('\n', charPos);
            if (fromPos < 0)
                fromPos = 0;
            int toPos = string.indexOf('\n', charPos);
            if (toPos < 0)
                toPos = string.length();
            String before = (fromPos < charPos ? string.substring(fromPos,
charPos) : "");
            String after = (charPos < toPos ? string.substring(charPos, toPos)
: "");
            String report = message + " at line " + lineNo + ":\n";
            if (!before.matches("\\s*")) {
                report += before;
                if (!before.matches("(?s).*\n\\s*"))
                    report += "\n";
            }
            report += "***HERE***\n";
            if (!after.matches("\\s*")) {
                report += after;
                if (!after.matches("(?s).*\n\\s*"))
                    report += "\n";
            }
            errors.add(report);
        } else
            errors.add(message + "\n");
    }

    // As above, but terminate parsing.
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        done_parsing();
    }

:};

// Terminals.

terminal MINUS;

terminal CARET;
terminal QUESTION;
terminal QUESTIONQUESTION;
terminal String TEXTSUPER;

terminal EXCLAM;
terminal EXCLAMEXCLAM;

terminal HIERO;
terminal String ALPHA;
terminal String EXTRA;

terminal String ASTERISK;
terminal String COLON;
terminal OPEN;
terminal CLOSE;

terminal STACK;

terminal String LIGATURE;

terminal String SIGN;

terminal MIRROR;
terminal String ROTATE;
terminal String MIRRORROTATE;
terminal String SCALE;

terminal REDGLYPH;
terminal GRAYGLYPH;

terminal WHOLESHADE;
terminal HORIZONTALSHADE;
terminal VERTICALSHADE;
terminal QUARTERSHADE;

terminal QUARTERBLANK;
terminal WHOLEBLANK;

terminal String BEGINBOX;
terminal String ENDBOX;

terminal String QUADRATSHADE;

terminal COLORTOGGLE;
terminal RED;
terminal BLACK;

terminal SHADINGTOGGLE;
terminal SHADINGON;
terminal SHADINGOFF;

terminal String BEGINPHIL;
terminal String ENDPHIL;

// Nonterminals.

nonterminal String mdc_file;
nonterminal ContentMatter top_groups;
nonterminal ResSwitch seps;
nonterminal ResSwitch sep;
nonterminal Object top_group;
nonterminal SwitchAndTopgroup quadrat;
nonterminal SwitchAndTopgroup vertical_list;
nonterminal SwitchAndTopgroup horizontal_list;
nonterminal SwitchAndTopgroup basic_group;
nonterminal SwitchAndTopgroup subgroup;
nonterminal SwitchAndHieroglyphic simple_groups;
nonterminal SwitchAndTopgroup simple_group;
nonterminal ResStack stack;
nonterminal Vector ligature;
nonterminal ResTopgroup hieroglyph;
nonterminal ResNamedglyph glyph;
nonterminal Vector glyph_modifiers;
nonterminal Vector glyph_modifier;
nonterminal ResEmptyglyph shade;
nonterminal ResEmptyglyph blank;
nonterminal Vector opt_blank_modifier;
nonterminal SwitchAndTopgroup box;
nonterminal Vector shading;
nonterminal ResSwitch toggle;
nonterminal SwitchAndTopgroup philology;

// Grammar.

mdc_file ::= 
	top_groups:e 
		{: RESULT = e.toString(); :} 
	;

top_groups ::=
	seps:e
		{: /* ignore e */
		   RESULT = new ContentMatter(); :} |
	top_groups:e1 top_group:e2 
		{: RESULT = e1.add(e2); :} 
	;

seps ::=
	/* empty */ 
		{: RESULT = new ResSwitch(); :} |
	seps:e1 sep:e2
		{: RESULT = e1.join(e2); :}
	;

sep ::=
	MINUS 
		{: RESULT = new ResSwitch(); :} |
	toggle:e
		{: RESULT = e; :} 
	;

top_group ::=
	quadrat:e 
		{: RESULT = parser.aux.normalize(e); :} |
	box:e 
		{: RESULT = parser.aux.normalize(e); :} |
	CARET seps:e
		{: RESULT = parser.aux.string("<-->", e); :} |
	QUESTION seps:e
		{: RESULT = parser.aux.string("--", e); :} |
	QUESTIONQUESTION seps:e
		{: RESULT = parser.aux.string("----", e); :} |
	TEXTSUPER:e1 seps:e2
		{: /* ignore e2 */
		   RESULT = "</phrase>\\n\\n<phrase><coord id=\"" + e1 + "\"/>"; :} |
	EXCLAM seps:e
		{: /* ignore e */
		   RESULT = "\n"; :} |
	EXCLAMEXCLAM seps:e
		{: /* ignore e */
		   RESULT = "\n"; :} |
	HIERO seps:e
		{: /* ignore e */
		   RESULT = "\n"; :} |
	ALPHA:e1 seps:e2
		{: /* ignore e2 */
		   RESULT = "<textal>" + e1 + "</textal>\n"; :} |
	EXTRA:e1 seps:e2
		{: /* ignore e2 */
		   RESULT = e1 + "\n"; :} |
	error
		{: RESULT = "\n"; :}
	;

quadrat ::=
	vertical_list:e1 
		{: RESULT = e1; :} |
	vertical_list:e1 shading:e2 seps:e3
		{: RESULT = e1.distribute(e2, e3); :}
	;

vertical_list ::=
	horizontal_list:e
		{: RESULT = e; :} |
	vertical_list:e1 COLON:e2 seps:e3 horizontal_list:e4
		{: RESULT = e1.addVert(e2, e3, e4); :}
	;

horizontal_list ::=
	basic_group:e
		{: RESULT = e; :} |
	horizontal_list:e1 ASTERISK:e2 seps:e3 basic_group:e4
		{: RESULT = e1.addHor(e2, e3, e4); :}
	;

basic_group ::=
	hieroglyph:e 
		{: RESULT = new SwitchAndTopgroup(e); :} |
	stack:e 
		{: RESULT = new SwitchAndTopgroup(e); :} |
	ligature:e 
		{: RESULT = parser.aux.ligature(e); :} |
	philology:e 
		{: RESULT = e; :} |
	subgroup:e 
		{: RESULT = e; :}
	;

subgroup ::= 
	OPEN simple_groups:e1 CLOSE seps:e2
		{: RESULT = e1.horgroup(e2); :}
	;

simple_groups ::=
	seps:e
		{: RESULT = new SwitchAndHieroglyphic(e); :} |
	simple_groups:e1 simple_group:e2 
		{: RESULT = e1.add(e2); :} 
	;

simple_group ::=
	quadrat:e 
		{: RESULT = e; :} |
	box:e 
		{: RESULT = e; :} 
	;

stack ::=
	hieroglyph:e1 STACK seps:e2 hieroglyph:e3
		{: RESULT = new ResStack(e1, e3, e2); :}
	;

ligature ::=
	glyph:e1 LIGATURE:e2 glyph:e3
		{: RESULT = parser.aux.ligature(e1, e2, e3); :} |
	ligature:e1 LIGATURE:e2 glyph:e3
		{: RESULT = parser.aux.ligature(e1, e2, e3); :} 
	;

hieroglyph ::=
	glyph:e
		{: RESULT = e; :} |
	shade:e
		{: RESULT = e; :} |
	blank:e 
		{: RESULT = e; :} 
	;

glyph ::=
	SIGN:e1 glyph_modifiers:e2 seps:e3
		{: RESULT = parser.aux.sign(e1, e2, e3); :} 
	;

glyph_modifiers ::=
	/* empty */
		{: RESULT = new Vector(); :} |
	glyph_modifiers:e1 glyph_modifier:e2 
		{: e1.addAll(e2); RESULT = e1; :}
	;

glyph_modifier ::=
	MIRROR
		{: RESULT = parser.aux.args("mirror"); :} |
	ROTATE:e
		{: RESULT = parser.aux.rotateArgs(e); :} |
	MIRRORROTATE:e
		{: RESULT = parser.aux.mirrorRotateArgs(e); :} |
	SCALE:e
		{: RESULT = parser.aux.scaleArgs(e); :} |
	REDGLYPH
		{: RESULT = parser.aux.args("red"); :} |
	GRAYGLYPH
		{: RESULT = parser.aux.args("gray"); :}
	;

shade ::=
	WHOLESHADE seps:e
		{: RESULT = parser.aux.empty("shade", e); :} |
	HORIZONTALSHADE seps:e
		{: RESULT = parser.aux.empty("t", e); :} | 
	VERTICALSHADE seps:e
		{: RESULT = parser.aux.empty("s", e); :} | 
	QUARTERSHADE seps:e
		{: RESULT = parser.aux.empty("ts", e); :} 
	;

blank ::=
	QUARTERBLANK opt_blank_modifier:e1 seps:e2
		{: RESULT = parser.aux.empty(e1, e2); :} |
	WHOLEBLANK opt_blank_modifier:e1 seps:e2
		{: RESULT = parser.aux.empty(e1, e2); :}
	;

opt_blank_modifier ::=
	/* empty */
		{: RESULT = new Vector(); :} |
	SCALE:e
		{: RESULT = parser.aux.scaleBlank(e); :}
	;

box ::= 
	BEGINBOX:e1 simple_groups:e2 ENDBOX:e3 seps:e4 
		{: RESULT = parser.aux.box(e1, e3, e2, new Vector(), e4); :} |
	BEGINBOX:e1 simple_groups:e2 ENDBOX:e3 seps:e4 shading:e5 seps:e6
		{: RESULT = parser.aux.box(e1, e3, e2, e5, e4.join(e6)); :} 
	;

shading ::=
	QUADRATSHADE:e1 
		{: RESULT = parser.aux.shading(e1); :} 
	;

toggle ::=
	COLORTOGGLE
		{: RESULT = parser.aux.switchs("blue"); :} |
	RED
		{: RESULT = parser.aux.switchs("red"); :} |
	BLACK
		{: RESULT = parser.aux.switchs("black"); :} |
	SHADINGTOGGLE
		{: RESULT = parser.aux.switchs("shade"); :} |
	SHADINGON
		{: RESULT = parser.aux.switchs("shade"); :} |
	SHADINGOFF
		{: RESULT = parser.aux.switchs("noshade"); :} 
	;

philology ::=
	BEGINPHIL:e1 seps:e2
		{: RESULT = parser.aux.string(e1, e2); :} |
	ENDPHIL:e1 seps:e2
		{: RESULT = parser.aux.string(e1, e2); :}
	;
